\section{Agent}

\subsection{Comportements}
\paragraph{}Le but était d'implémenter deux types de comportement :
constructeur et destructeur. Le
comportement de type constructeur (ogre) doit permettre de rassembler les objets
en endroit du terrain. Le comportement de type destructeur (robot) a pour
objectif de disperser les objets sur le terrain.

La classe \texttt{Behavior} regroupe les méthodes de bases. On trouve des
méthodes pour effectuer un déplacement vers une position visée, pour choisir
une nouvelle destination. La méthode \texttt{Update} sera appelée à chaque frame.

Afin de rassembler le code en commun dans les comportements constructeurs et
destructeurs, une classe \texttt{CarriedBehavior} a été faites. Cette classe
hérite donc de la classe \texttt{Behavior}.  Elle rassemble les mécanisme pour
ramasser des objets et les déposer. Nos comportements constructeurs et destructeurs
hérite de cette classe.


\subsubsection{Builder}
\paragraph{}Pour les comportement de type constructeur deux types de comportement ont été
réalisés. Le premier comportement \texttt{BuilderBehavior} peut être assimilé à un petit automate à 4 états.


\begin{description}
    \item[\'Etat 1] l'ogre ne porte pas d'objet. Si un objet est à porté il
        le ramasse et passe dans l'état 2.
    \item[\'Etat 2] l'ogre vient de ramasser un objet. Il se déplace pendant une
        durée aléatoire sans faire d'autres actions puis passe dans l'état 3.
    \item[\'Etat 3] l'ogre porte un objet. Si un objet est à porté il
        dépose l'objet qu'il porte à côté de celui-ci. Il passe ensuite dans
        l'état 4.
    \item[\'Etat 4] l'ogre vient de poser un objet. Il se déplace pendant une
        durée aléatoire sans faire d'autres actions puis passe dans l'état 1.
\end{description}

\paragraph{}Grâce à ce comportement les ogres sont capables de rassembler les caisses
petit à petit. On voir rapidement émerger plusieurs tas. Cependant la
convergence vers un seul tas unique peut être particulièrement longue.

\paragraph{}Le deuxième comportement \texttt{CleverBuilderBahavior} est quand à lui plus
complexe. On ajoute une mémoire aux ogres : ils se rappellent l'endroit où ils ont vu le
plus de caisses. Et ainsi, quand ils désirent poser leur objet ils se rendent à
cet endroit.

\begin{description}
    \item[\'Etat 1] l'ogre ne porte pas d'objet. Si un objet est à porté il
        le ramasse et passe dans l'état 2.
    \item[\'Etat 2] l'ogre vient de ramasser un objet. Il se déplace pendant une
        durée aléatoire en regardant le nombre d'objets qui sont dans son
        champ de vision et en mettant à jour sa mémoire si il découvre un
        endroit avec un nombre d'objet supérieure. Puis il passe dans l'état 3.
    \item[\'Etat 3] l'ogre porte un objet. L'ogre se rend à l'endroit
        enregistré dans sa mémoire et y dépose l'objet. Il profite pour mettre
        le nombre d'objet s'y trouvant à jour par la même occasion. Il passe
        ensuite dans l'état 4.
    \item[\'Etat 4] l'ogre vient de poser un objet. Il se déplace pendant une
        durée aléatoire sans faire d'autres actions puis passe dans l'état 1.
\end{description}

\paragraph{}Ce comportement permet d'augmenter de façon importante l'efficacité
des ogres. Au bout d'une durée relativement courte les ogres ont tous trouvé
l'endroit comportent le plus de caisses.

\subsubsection{Wrecker}
\paragraph{}Au niveau du comportement de type destructeur, une seule version a
été implementé : \texttt{WrekerBehavior}. Celle-ci ressemble fortement au premier comportement des
ogres mais les conditions pour poser un objet sont différentes.

\begin{description}
    \item[\'Etat 1] l'ogre ne porte pas d'objet. Si un objet est à porté il
        le ramasse et passe dans l'état 2.
    \item[\'Etat 2] l'ogre vient de ramasser un objet. Il se déplace pendant une
        durée aléatoire sans faire d'autres actions puis passe dans l'état 3.
    \item[\'Etat 3] l'ogre porte un objet. Si aucun objet est à porté il
        dépose l'objet qu'il porte. Il passe ensuite dans
        l'état 4.
    \item[\'Etat 4] l'ogre vient de poser un objet. Il se déplace pendant une
        durée aléatoire sans faire d'autres actions puis passe dans l'état 1.
\end{description}

\paragraph{}Ce comportement permet au robot de disséminer les caisses.
Cependant, on remarque que l'efficacité de ce comportement augmente quand les
caisses ne sont pas réparties de façon homogène sur l'ensemble du terrain. En
effet, dans ce cas là les robots peuvent alors mettre en temps important à
trouver un endroit où ils n'ont pas d'autres caisses en vue.

\section{Fonctionnalités}


\subsection{Techniques mises en place}
\subsubsection{SkyBox}
Nous avons essayé plusieurs méthodes pour le ciel : SkyBox et SkyDome. Le
skydome n'était pas adapté à notre application. Notre terrain étant une
surface carré de dimension fini il était possible voir le bas du skydome.
Or, comme le skydome consiste à appliquer une image carré sur un dôme, le
rendu sur le bas du dôme est déformé. Il est donc préférable d'utiliser une
skybox.

\subsubsection{Mesh}
Pour réaliser nos caisses, nous avons utiliser le logiciel de modélisation 3D
blender afin de réaliser le mesh. Le mesh correspond tout simplement à un
cube. Nous avons ensuite fais une texture basique avec gimp que nous avons
appliqué sur notre cube en utilisant la méthode "UV texture map".
Nous avons ensuite exporté le mesh afin de le mettre dans le format
accepté par le moteur Ogre3D.

% Fog ?
% Lights ?

\subsubsection{Overlays}
% Aide

\paragraph{Information}
Cet overlay permet l'affichage de plusieurs informations au sujet de la
simulation, notamment le nombre d'agents de chaque type et le temps écoulé
depuis le lancement de la simulation.
En plus de cela, le facteur de vitesse d'écoulement du temps - détaillé par la
suite - est également affiché. Lorsque ce facteur est inférieur à 1, la
simulation est ralentie alors que quand il est supérieur à 1, la simulation
est accélérée. Nous avons fait en sorte que le temps écoulé depuis le début de
la simulation évolue plus ou moins rapidement en fonction de ce facteur.

\subsection{Interaction avec l'utilisateur}

L'utilisateur peut interagir avec l'environnement avec la souris ou au
clavier. La touche \verb!h! affiche la liste des commandes possible et la
touche i affiche des informations à propos de l'environnement.
Il est possible de déplacer la caméra dans la scène grâce à des touches
clavier et d'effectuer des rotations grâce à la souris - l'appui de la touche
\emph{shift} permet d'accélérer les translations de la caméra.

\subsubsection{Saut dans le temps et téléportation}
Pour permettre à l'utilisateur d'observer plus finement le comportement des
agents et pour voir un comportement à l'échelle macroscopique se dégager plus
rapidement, nous avons ajouté la possibilité de ralentir et d'accélérer le
temps - il est également possible d'arrêter le temps, c'est-à-dire de faire
une pause de la simulation. Dans un premier temps nous nous étions contenté de
multiplier la vitesse de base de nos agent par un facteur pour donner cette
sensation d'évolution plus lente ou plus rapide. Nous nous sommes alors aperçu
que, si cela fonctionnait bien lorsqu'on ralentissait la vitesse des agents,
lors d'une augmentation de la vitesse des agents le résultat différait de ce
que l'on attendait.

\paragraph{}
L'explication est simple, à chaque frame on calcule la nouvelle position des
agents en fonction du temps qui s'est écoulé depuis la dernière frame et de la
vitesse de l'agent. Par conséquent entre 2 frames consécutives les agents se
"téléportent" tous de leur position courante à leur nouvelle position. Lorsque
la vitesse des agents est élevée, la téléportation s'effectue sur une plus
grande distance. Le problème est que nos agents sont sensés ramasser des items
ou en déposer sous certaines conditions lorsque leur trajectoire les fait
passer près d'un item. Si la vitesse d'un agent est trop élevée, ce dernier
risque de se téléporter trop loin des items qui étaient sur sa trajectoire et
ne va donc pas les voir. On observer ainsi que lorsqu'on accélérait la vitesse
de la simulation, les agents avaient tendance à ne plus ramasser correctement
les caisses et donc on perdait l'intérêt de la démarche.

\paragraph{}
Pour palier à ce problème nous avons géré différemment l'augmentation et la
diminution de la vitesse à laquelle s'écoule le temps. Nous avons gardé la
même technique pour "ralentir" la simulation. Pour l'accélérer, nous avons
fait en sorte que, lorsque le \emph{FrameListener} appelle notre fonction de
mise à jour de la scène, plusieurs frames soient calculée au lieu d'une seule.
De cette manière les agents n'atteignent pas de vitesse trop élevée et le bon
résultat est obtenu.

% Mesh selection ?
% -> put a light on an agent
% -> kill an agent
% -> move an agent
% Overlay
% -> help (key bindings)
% -> informations (nb of each agent/death/birth, life speed, time from start)
% -> debugging ?
% Pause
% Ambient light
